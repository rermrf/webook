### gRPC中默认的负载均衡算法：

grpc在默认情况下，**可以认为是没有负载均衡算法的，因为它永远只会选择第一个节点**。

这个第一个节点是你在 Resolver 里面解析出来的第一个节点。当然大多数时候，第一个节点是什么你一点都不关心，也没啥影响。


### gRPC 中使用 round_robin 算法
gRPC 提供了一些复杂均衡算法的实现，可以直接使用。

比如说**轮训算法，大多数时候你直接使用这个算法就足够了**。

要注意，这里是一个 gRPC 的垃圾设计，即传入 JSON 串。这里很容易写错。

```go
bd, err := resolver.NewBuilder(client)
	if err != nil {
		panic(err)
	}
opts := []grpc.DialOption{grpc.WithResolvers(bd), grpc.WithDefaultServiceConfig(`{"loadBalancingConfig":[{"round_robin":{}}]}`)}
```

round_robin 没有任何配置，所以后面就是一个 {}


### gRPC round_robin 算法实现
gRPC 的 round_robin **算法实现很简单，核心就是利用原子操作来更新候选节点的下表**。

```go
type rrPicker struct {
	// subConns is the snapshot of the roundrobin balancer when this picker was
	// created. The slice is immutable. Each Get() will do a round robin
	// selection from it and return the selected SubConn.
	subConns []balancer.SubConn
	next     uint32
}

func (p *rrPicker) Pick(balancer.PickInfo) (balancer.PickResult, error) {
	subConnsLen := uint32(len(p.subConns))
	nextIndex := atomic.AddUint32(&p.next, 1)

	sc := p.subConns[nextIndex%subConnsLen]
	return balancer.PickResult{SubConn: sc}, nil
}
```


### gRPC 中使用加权负载均衡算法
gRPC 本身就提供了加权负载均衡算法实现。

使用起来有两个地方需要修改：
- **匿名引入基于权重的负载均衡算法**，也就是初始化好这个算法。
- **在客户端启动的时候指定使用加权轮训算法。**

```go
import (
    _ "google.golang.org/grpc/balancer/weightedroundrobin"
)
opts := []grpc.DialOption{
grpc.WithResolvers(bd),
// 使用轮训负载均衡算法
grpc.WithDefaultServiceConfig(`{"loadBalancingConfig":[{"weighted_round_robin": {}}]}`),
}
```

#### 匿名引入的意义
匿名引入就是为了初始化好这个算法。

**也就是触发包中的 init 方法。**

这个在 Go 里面是非常常见的一种设计模式。即提供一个中间的注册方法，而后通过匿名引入来注册某个实现。

后续的所有使用的地方，都根据注册的名字来查找对应的实现。


#### 加权负载均衡算法原理
gRPC 中的加权均衡算法并不是我们之前讨论的服务端配置权重的加权算法。gRPC 是自己主动计算每个节点的权重。它会根据每个节点的 QPS、错误率来计算一个权重。

简单来说，**QPS 越高，权重越大；错误率越高，权重越低**。而后，利用 EDF 算法（Earliest Deadline First）从这些节点里面挑选出来一个。


### gRPC 中支持其他负载均衡算法
gRPC 自带的负载均衡算法你可以在 gRPC 下的子包 balancer 里面找到。
- grpclb：统一控制负载均衡的实现，用来集成其他负载均衡算法实现的，不需要用。
- leastrequest：最少请求数算法，实验特性，不要用。
- rls：集成了限流的负载均衡算法实现，也要配合其他负载均衡算法来使用，实验特性，不要用。
- roundrobin：轮询。
- weightedroundrobin：加权轮训。

总结就是，**除了 roundrobin 其他都没什么使用的必要。**


### 在 gRPC 中接入自己的负载均衡算法
有时候你需要根据业务特征来定制一些负载均衡算法，那么**就需要了解怎么接入自定义的算法**。

在 gRPC 里面，实现一个自定义算法，需要实现两个关键接口：
- PickerBuilder：它在 balancer.base 子包里面。
- Picker：在 balancer 子包下面。

```go
package wrr

import (
	"google.golang.org/grpc/balancer"
	"google.golang.org/grpc/balancer/base"
)

const name = "custom_wrr"

func init() {
	// NewBalancerBuilder 是帮我们把一个 Picker Builder 转化为一个 balancer builder
	balancer.Register(base.NewBalancerBuilder(name, &PickerBuilder{}, base.Config{HealthCheck: true}))
}

//传统版本的基于权重的负载均衡算法

type PickerBuilder struct {
}

func (p *PickerBuilder) Build(info base.PickerBuildInfo) balancer.Picker {
	var conns []*conn
	for sc, scInfo := range info.ReadySCs {
		cc := &conn{
			cc: sc,
		}

		md, ok := scInfo.Address.Metadata.(map[string]any)
		if ok {
			weightVal := md["weight"]
			weight, _ := weightVal.(float64)
			cc.weight = int(weight)
		}

		if cc.weight == 0 {
			cc.weight = 50
		}
		cc.currentWeight = cc.weight
		conns = append(conns, cc)

	}
	return &Picker{
		conns: conns,
	}
}

// Picker 这个才是真的执行负载均衡的地方
type Picker struct {
	conns []*conn
}

// Pick 在这里实现基于权重的负载均衡算法
func (p *Picker) Pick(info balancer.PickInfo) (balancer.PickResult, error) {
	if len(p.conns) == 0 {
		// 没有候选节点
		return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
	}
	var total int
	var maxCC *conn
	// 计算当前权重
	for _, cc := range p.conns {
		total += cc.weight
		cc.currentWeight += cc.weight
		if maxCC == nil || cc.currentWeight > maxCC.currentWeight {
			maxCC = cc
		}
	}
	// 更新
	maxCC.currentWeight -= total
	// maxCC 就是挑出来的
	return balancer.PickResult{
		SubConn: maxCC.cc,
		Done: func(info balancer.DoneInfo) {
			// 很多动态算法，根据通用结果来调整权重，就在这里
		},
	}, nil
}

// conn 代表节点
type conn struct {
	// 权重
	weight        int
	currentWeight int

	// 真正的，grpc 里面的代表一个节点的表达
	cc balancer.SubConn
}

```

#### 自定义基于权重的负载均衡算法
这个算法的要点：
- **要在客户端这边拿到服务端节点的权重。**
- **利用权重实现一个平滑的基于权重的负载均衡算法。**

之前我们提到过，要在服务端到客户端之间传递元数据，那么就要利用到注册时候的 metadata 字段。

大部分时候，**每一个节点的权重信息都是从配置文件或者环境变量里面读取到的。**



### Kratos 中的负载均衡：默认算法

**在默认情况下，Kratos 使用的是平滑的加权轮训算法**。也就是，你不指定使用任何负载均衡算法的时候，用的就是这个。

实际上，在 Kratos 里面，负载均衡被进一步抽象（封装）为了一个 Selector 概念，允许你传入一些 filter 来过滤一些服务端节点。

这个 filter 功能你可以看做是分组/路由的统一抽象。


#### Kratos 中支持的负载均衡算法
- P2C（Pick of 2 Choices）：简单来说就是先随机选出两个节点，这两个节点需要满足一定的条件，而后再从这两个节点里面选出一个负载比较低的节点。
- Random：随机负载均衡算法。
- WRR：平滑肌的加权负载均衡算法。

**正常默认使用 WRR 就可以了。**



### go-zero 中的负载均衡
go-zero的默认负载均衡算法是 p2c。
并且，这个框架内部直接写死的
如果要修改，就必须**传入一个原生的grpc.WithDefaultServiceConfig 覆盖掉**。


### 总结
- 不管是自定义负载均衡算法，还是不同框架接入负载均衡，只要是用的是 gRPC，那么就**绕不开 PickBuilder 和 Picker两个接口。**
- 进一步可以推论，这些框架基本上也是**借助 WithDefaultServiceConfig 来指定负载均衡算法的。**
- 已有的负载均衡实现已经能够解决大多数问题了，除非逼不得已，**已经不需要实现自定义的负载均衡算法了**。

