## 为什么要迁移
在经过微服务化之后，我们的代码已经拆除去了，但是还在共享一个数据库（逻辑上和物理上都是一个数据库）.

在微服务的理论里面，有一个广泛认同的观点：**即某个微服务的数据也要单独存储的**。因此，正常在微服务化之后，我们还要把所有的数据都分离了，单独存储。


### 异构数据迁移

这里说的异构数据迁移，**是指原表和目标表的结构不一样**。

显然，**如果数据库都不一样，也算是异构数据迁移**。比如说 MYSQL 迁移到 MongoDB，一般数据量大了又懒得分库分表，就可能用 MongoDB。

异构数据迁移会更加复杂，因为数据转换 - 完整性校验都很麻烦。
- **数据转换**：最麻烦的就是不同数据类型转换可能出现不兼容的问题，如果是数字，还可能会有精度问题。还有长度限制，则有溢出问题。
- **完整性校验**：也就是常见的外间约束，数据之间的业务关系等，都很难验证。


### 停机迁移
最自然的想法就是：
- **停下应用；**
- **从老库中导出数据；**
- **倒入数据到新库中；**

这个方案在中小型应用中很常见，或者额在一些不重要的业务中也很常见。

缺陷：应用停下来了
如果数据量很多，那么不管是导出，还是导入数据，都非常慢。这就是意味着你的应用要停很久。


## 不停机迁移方案

在停机迁移方案里面，我们知道停机迁移对用户体验的伤害是非常大的，所以基本上在现实中，核心应用都是不停机迁移数据。

这意味着：
- **当你一遍迁移数据，一边又有新数据产生，或者老数据被更新了。**
- **当你迁移数据的时候，你不能对数据库造成太大的压力，否则会影响应用的正常运行。**

### 不停机迁移的难点
整个不停机的迁移的核心难点就是：**数据始终处于变动之中**。


### 不停机迁移的四个阶段
- **第一阶段：业务读写源表。** 在这个阶段你要完成目标表的数据初始化过程。
- **第二阶段：双写阶段，以源表为准**。在这个阶段数据会被双写到源表和目标表中，并且读是读源表，如果数据不一致，也是以源表的数据为准。
- **第三阶段：双写阶段，以目标表为准**。在这个阶段，数据也是保持双写，但是读以目标表为准，并且修复数据的时候，是以目标表为准。
- **第四阶段：业务读写目标表**。